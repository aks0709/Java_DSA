package preRequisites.BinarySearch;

public class SearchMinInRotatedSortedArray {
    class Solution {
        public int findMin(int[] nums) {
            int n=nums.length;
            int l=0;
            int h=n-1;
            int min=nums[(l+h)/2];
            while(l<=h){
                int mid=l+(h-l)/2;
                if(nums[mid]<=min)
                    min=nums[mid];

                //three condition i generated by doing dry run
                if(nums[l]<=nums[mid]&&nums[mid]<=nums[h])
                    h=mid-1;
                else if(nums[mid]<=nums[l] && nums[mid]<=nums[h])
                {
                    if(nums[l]>=nums[h])
                        h=mid-1;
                    else
                        l=mid+1;
                }
                else if(nums[mid]>=nums[l]&&nums[mid]>=nums[h]){
                    if(nums[l]<=nums[h])
                        h=mid-1;
                    else
                        l=mid+1;
                }
            }
            return min;
        }

        public static int findMin2(int []arr) {
            int low = 0, high = arr.length - 1;
            int ans = Integer.MAX_VALUE;
            while (low <= high) {
                int mid = (low + high) / 2;

                //search space is already sorted
                //then arr[low] will always be
                //the minimum in that search space:
                if (arr[low] <= arr[high]) {
                    ans = Math.min(ans, arr[low]);
                    break;
                }

                //if left part is sorted:
                if (arr[low] <= arr[mid]) {
                    // keep the minimum:
                    ans = Math.min(ans, arr[low]);

                    // Eliminate left half:
                    low = mid + 1;

                } else { //if right part is sorted:

                    // keep the minimum:
                    //it means the middle is the smallest in right half
                    ans = Math.min(ans, arr[mid]);

                    // Eliminate right half:
                    high = mid - 1;
                }
            }
            return ans;
        }

    }

}
